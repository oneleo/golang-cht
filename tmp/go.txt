
Go 的遊樂場 
https://play.golang.org/

【Run】：可以在 Google 的伺服器上編譯並執行用戶輸入的程式碼。
【Format】：Go 編譯器有一個叫做 go fmt 的標準格式化工具。這個 Format 按就是網頁版的 go fmt。
【Imports】：若勾選，當按下【Format】會自動新增、刪除主要程式碼中有用到、沒有用到的套件。
【Share】：將您當下的程式碼內容，產生一個獨一無二的分享連結。

// ------------------------------------------------------------

【package main】- 套件字句：這一行說該份檔案中所有的程式碼都歸屬於「main」套件。

【import (
	"fmt"
)】- 匯入段落：這裡說我們即將從「fmt」套件使用可讓文字格式化的程式碼。


【func main() {
	fmt.Println("Hello, playground")
}】- 主要程式碼

【func main() {}】- 「main」函式是特別的；當您的程式啟動時它會第一個被執行。
【fmt.Println("Hello, playground")】- 這一行會在您的終端機（或者網頁瀏覽器，假如您是用 Go 遊纅場）顯示印出。
【fmt.Println()】- 這裡會調用「fmt」套件的函式「Println」

// ------------------------------------------------------------

假如您這麼做…它會因為…而發生錯誤
1、刪除套件子句
package main
→ 每個 Go 檔案必須以套件子句作為開頭

2、刪除 import 陳述句
import "fmt"
→ 每個 Go 檔案必須透過匯入的方式引用套件

3、匯入第二個（沒用到的）套件：import "strings"
import "fmt"
import "strings"
→ Go 必須只匯入有在程式碼當中引用的套件（這讓您的程式碼編譯得更快！）

4、重新命名為 main 函式：func hello()
func hello
→ Go 會優先執行名為 main 的函式。

4、把 Println 改為小後調用：fmt.println("Hello, playground")
fmt.println("Hello, Go!")
→ Go 是有區分大小寫的，縱使 fmt.Println 可用，並不代表 fmt.println 也可行。 

5、把 Println 之前的套件名稱刪除：Println("Hello, playground")
Println("Hello, Go!")
→ Println 函式並不是 main 套件的一部分，於是 Go 調用該函式時需要它的套件名稱。

// ------------------------------------------------------------




// ------------------------------------------------------------

func main() {
	var a int = 0
	var b int = 1
	fmt.Print(a)

	for i := 0; i < 5; i++ {
		fmt.Print(" ", b)
		tmp := a
		a = b
		b = tmp + a
	}
}





// ------------------------------------------------------------

	var (
		a int = 0
		b int = 1
	)

// ------------------------------------------------------------

	a := 0
	b := 1

// ------------------------------------------------------------

func main() {
	a := 0
	b := 1
	fmt.Print(a)

	for i := 0; i < 10; i++ {
		fmt.Print(" ", b)
		a, b = b, a+b
	}
}


// ------------------------------------------------------------

func main() {
	quantity := 4
	length, width := 1.2, 2.4
	customerName := "Damon Cole"

	fmt.Println(customerName)
	fmt.Println("has ordered", quantity, "sheets")
	fmt.Println("each with an area of")
	fmt.Println(length*width, "square meters")
}

假如您這麼做：
對同一個變數進行第二次宣告
quantity:=4
quantity:=4
→ 同一個變數只能宣告一次（縱使您可以隨時指派新的值給它，您也可以在別的範圍宣告同一個變數名稱。我們會在下一章學到什麼是範圍）

刪除短變數宣告的:
quantity=4
→ 假如您忘了:，它會被當作指派而不是宣告，而您不能對還沒宣告的變數指派值

把string的值指派給int的變數
quantity:=4
quantity="a"
→ 變數只能指派同一個型別的值

變數與值的數量不同
length, width:=1.2
→ 您得提供每一個變數相對應的值，反過來說每一個值都得對應到一個變數
可以加空白

移除有用到變數的程式碼
fmt.Println(customerName)
→ 所有的變數都應該在您的程式中被使用到。假如您移除了用到變數的程式碼，您也得移除該變數的宣告。

// ------------------------------------------------------------



// ------------------------------------------------------------


常數

**1. 每當定義一個const，iota的初始值為0

每當定義一個常量，就會自動累加1**
直到下一個const出現，清零
如果中斷iota自增，則必須顯式恢復。且後續自增值按行序遞增
5. 自增預設是int型別，可以自行進行顯示指定型別
6. iota 可以參與運算

type Weekday int

const (
	Unknown Weekday = iota
	Sunday
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
)

const (
	Open = 1 << iota
	Close
	Pending
)

const (
        b  = 1 << (iota * 10) // iota初始值為0 ，所以 1 << (0 * 10)
        kb                    // 1 << (1 * 10)
        mb                    // 1 << (2 * 10)
        gb                    // 1 << (3 * 10)
        tb                    // 1 << (4 * 10)
        pb                    // 1 << (5 * 10)
    )

const (
	Readable = 1 << iota
	Writable
	Executable
)

func main() {
	a := 7
	a = 1
	fmt.Print(a&Readable == Readable, a&Writable == Writable, a&Executable == Executable)
}

// ------------------------------------------------------------

https://wizardforcel.gitbooks.io/gopl-zh/content/ch2/ch2-01.html

此外，還有大約30多個預定義的名字，比如int和true等，主要對應內建的常量、類型和函數。

內建常量: true false iota nil

內建類型: int int8 int16 int32 int64
          uint uint8 uint16 uint32 uint64 uintptr
          float32 float64 complex128 complex64
          bool byte rune string error

內建函數: make len cap new append copy close delete
          complex real imag
          panic recover
這些內部預先定義的名字併不是關鍵字，你可以再定義中重新使用它們。在一些特殊的場景中重新定義它們也是有意義的，但是也要註意避免過度而引起語義混亂。

基本資料型別
https://pkg.go.dev/go/types#BasicKind

    // predeclared types
    Bool
    Int
    Int8
    Int16
    Int32
    Int64
    Uint
    Uint8
    Uint16
    Uint32
    Uint64
    Uintptr
    Float32
    Float64
    Complex64
    Complex128
    String
    UnsafePointer

    // types for untyped values
    UntypedBool
    UntypedInt
    UntypedRune
    UntypedFloat
    UntypedComplex
    UntypedString
    UntypedNil

    // aliases
    Byte = Uint8
    Rune = Int32


// ------------------------------------------------------------

Go 語言不允許隱式"類型轉換"
別名和原有的類型也不能進行隱式類型轉換

type MyInt int64

func main() {
	var a int32 = 1
	var b int64
	//b = a
	b = int64(a)
	var c MyInt
	//c = b
	c = MyInt(b)
	fmt.Print(a, b, c)
}



// ------------------------------------------------------------


指標類型
與其他主要程式語言的差異
1、不支持指標運算
2、string 是值類型，其預設的初始化值為空字串，而不是 nil

package main

import (
	"fmt"
	"math"
)

type MyInt int64

func main() {
	fmt.Println(math.MaxInt64, math.MaxFloat64, math.MaxUint32)
	a := 1
	aPtr := &a
	//aPtr = aPtr + 1
	fmt.Println(a, aPtr)
	fmt.Printf("%T %T", a, aPtr)
}

// ------------------------------------------------------------

類型的預定義值
https://pkg.go.dev/math#pkg-constants
const (
    MaxInt8   = 1<<7 - 1
    MinInt8   = -1 << 7
    MaxInt16  = 1<<15 - 1
    MinInt16  = -1 << 15
    MaxInt32  = 1<<31 - 1
    MinInt32  = -1 << 31
    MaxInt64  = 1<<63 - 1
    MinInt64  = -1 << 63
    MaxUint8  = 1<<8 - 1
    MaxUint16 = 1<<16 - 1
    MaxUint32 = 1<<32 - 1
    MaxUint64 = 1<<64 - 1
)

// ------------------------------------------------------------

func main() {
	var s string
	fmt.Println("*" + s + "*")
	fmt.Println(len(s))
	//if s == nil {
	//	fmt.Println("s is nil")
	//}
	if s == "" {
		fmt.Println("s is blank")
	}
}





// ------------------------------------------------------------

Zero value
understanding zero value

false for booleans
0 for integers
0.0 for floats
"" for strings
nil for 

pointers
functions
interfaces
slices
channels
maps

use short declaration operator as much as possible

use var for
zero value
package scope


// ------------------------------------------------------------

命名
https://golang.org/doc/effective_go.html#names

命名
檔案命名
檔案命名一律採用小寫，不用駝峰式，儘量見名思義，看見檔名就可以知道這個檔案下的大概內容。

其中測試檔案以 test.go結尾，除測試檔案外，命名不出現 。

例子：

stringutil.go， stringutil_test.go
包名package
包名用小寫,使用短命名,儘量和標準庫不要衝突。

包名統一使用單數形式。

變數
變數命名一般採用駝峰式，當遇到特有名詞（縮寫或簡稱，如DNS）的時候，特有名詞根據是否私有全部大寫或小寫。

例子：

apiClient、URLString
常量
同變數規則，力求語義表達完整清楚，不要嫌名字長。

如果模組複雜，為避免混淆，可按功能統一定義在package下的一個檔案中。

// ------------------------------------------------------------

保留字是可以更改的，但仍非常不建議用保留字來命名變數，會蓋掉內建保留字（名稱遮蔽，深P44）
https://github.com/golang/go/blob/master/src/builtin/builtin.go

// ------------------------------------------------------------


算術運算元
A=10 B=20
+ 相加 A+B輸出結果30
- 相減 A-B輸出結果-10
* 相乘 A*B輸出結果200
/ 相除 B/A 輸出結果2
% 求餘 B%A 輸出結果0
++ 自增 A++ 輸出結果11
-- 自減 A-- 輸出結果9
Go 語言沒有前置的 ++、--（++a、--b）



// ------------------------------------------------------------

比較運算元
== 檢查兩個值是否相等，如果相等回傳true否則傳回false (A==B)為false
!= 檢查兩個值是否不相等，如果不相等回傳true否則傳回false (A!B)為true
> 檢查左邊值是否大於右邊值，如果是回傳true否則傳回false (A>B)為false
< 檢查左邊值是否小於右邊值，如果是回傳true否則傳回false (A<B)為true
>= 檢查左邊值是否大於等於右邊值，如果是回傳true否則傳回false (A>=B)為false
<= 檢查左邊值是否小於等於右邊值，如果是回傳true否則傳回false (A<=B)為true

// ------------------------------------------------------------

用 == 比較陣列

相同維度且含有相同個數元素的陣列才可以比較
每個元素都相同的才相等

func main() {
	a := [...]int{1, 2}
	b := [...]int{1, 2}
	if reflect.DeepEqual(a, b) {
		fmt.Println("a is b")
	}

	if a == b {
		fmt.Println("a is b")
	}
}

// ------------------------------------------------------------

Byte 型別比較
https://www.mdeditor.tw/pl/pZdS/zh-tw

s1 := []byte{'f', 'o', 'o'}
s2 := []byte{'f', 'o', 'o'}
fmt.Println(bytes.Equal(s1, s2)) // true
s2 = []byte{'b', 'a', 'r'}
fmt.Println(bytes.Equal(s1, s2)) // false
s2 = []byte{'f', 'O', 'O'}
fmt.Println(bytes.EqualFold(s1, s2)) // true
s1 = []byte("źdźbło")
s2 = []byte("źdŹbŁO")
fmt.Println(bytes.EqualFold(s1, s2)) // true
s1 = []byte{}
s2 = nil
fmt.Println(bytes.Equal(s1, s2)) // true


// ------------------------------------------------------------

reflect.DeepEqual函式可以用來比較兩個任意型別的變數

func DeepEqual(x, y interface{})
對map型別做比較：

m1 := map[string]int{"foo": 1, "bar": 2}
m2 := map[string]int{"foo": 1, "bar": 2}
// fmt.Println(m1 == m2) // map can only be compared to nil
fmt.Println(reflect.DeepEqual(m1, m2)) // true
m2 = map[string]int{"foo": 1, "bar": 3}
fmt.Println(reflect.DeepEqual(m1, m2)) // false
m3 := map[string]interface{}{"foo": [2]int{1,2}}
m4 := map[string]interface{}{"foo": [2]int{1,2}}
fmt.Println(reflect.DeepEqual(m3, m4)) // true
var m5 map[float64]string
fmt.Println(reflect.DeepEqual(m5, nil)) // false
fmt.Println(m5 == nil) // true
對slice型別做比較：

s := []string{"foo"}
fmt.Println(reflect.DeepEqual(s, []string{"foo"})) // true
fmt.Println(reflect.DeepEqual(s, []string{"bar"})) // false
s = nil
fmt.Println(reflect.DeepEqual(s, []string{})) // false
s = []string{}
fmt.Println(reflect.DeepEqual(s, []string{})) // true
對struct型別做比較：

type T struct {
    name string
    Age  int
}
func main() {
    t := T{"foo", 10}
    fmt.Println(reflect.DeepEqual(t, T{"bar", 20})) // false
    fmt.Println(reflect.DeepEqual(t, T{"bar", 10})) // false
    fmt.Println(reflect.DeepEqual(t, T{"foo", 10})) // true
}

// ------------------------------------------------------------

邏輯運算元

&& 邏輯 AND 運算元，如果兩邊的操作數都是true則條件true否則為false (A && B)為false
|| 邏輯 OR 運算元，如果兩邊的操作數有一個true則條件true否則為false (A || B)為true
! 邏輯 NOT 運算元，如果條件為true則邏輯not條件false否則為true !(A && B)為true


// ------------------------------------------------------------

https://youtu.be/YdZj4u6Vtlo

& 按位與運算元&是雙目運算元，其功能是參與運算的兩數各對應的二進位相與
| 按位或運算元|是雙目運算元，其功能是參與運算的兩數各對應的二進位相或
^ 按位異或運算元^是雙目運算元，其功能是參與運算的兩數各對應的二進位互斥或，當兩對應的二進應相異時結果為 1
<< 左移運算元<<是雙目運算元，左移n位就是乘以2的n次方，其功能把<<左邊的運算數的各二進位全部左移若干位，由<<右邊的數指定移動的位數，高位丟棄，低位補0
>> 右移運算符>>是雙目運算元，右移n位就是除以2的n次方，其功能是把>>左邊的運算數的各二進位全部右移若干位>>右邊數指定移動的位數

a &^ b = (a &(^b)) 按位置零 bit clear
^ 逐一取 NOT 

func main() {
	a := byte(0b00111100)
	fmt.Printf("a = %08[1]b %02[1]d\n", a)
	b := byte(0b00001101)
	fmt.Printf("b = %08[1]b %02[1]d\n", b)
	fmt.Printf("a & b = %08[1]b %02[1]d\n", a&b)
	fmt.Printf("a | b = %08[1]b %02[1]d\n", a|b)
	fmt.Printf("a ^ b = %08[1]b %02[1]d\n", a^b)
	fmt.Printf("a << 2 = %08[1]b %02[1]d\n", a<<2)
	fmt.Printf("a >> 2 = %08[1]b %02[1]d\n", a>>2)

	fmt.Printf("^b = %08[1]b %02[1]d\n", ^b)
	fmt.Printf("a &^ b = %08[1]b %02[1]d\n", a&^b)
}


const (
	Readable = 1 << iota
	Writable
	Executable
)

func main() {
	a := 7
	fmt.Printf("a = %08[1]b %02[1]d\n", a)
	a = a &^ Readable
	fmt.Printf("a = %08[1]b %02[1]d\n", a)
	a = a &^ Executable
	fmt.Printf("a = %08[1]b %02[1]d\n", a)
	fmt.Print(a&Readable == Readable, a&Writable == Writable, a&Executable == Executable)
}

// ------------------------------------------------------------

優先權
https://golang.org/ref/spec#Operators


Precedence    Operator
    5             *  /  %  <<  >>  &  &^
    4             +  -  |  ^
    3             ==  !=  <  <=  >  >=
    2             &&
    1             ||

// ------------------------------------------------------------

字串

fmt.Printf("",)

活版印刷 字串特殊字元
https://golang.org/ref/spec#Rune_literals

\a   U+0007 alert or bell
\b   U+0008 backspace
\f   U+000C form feed
\n   U+000A line feed or newline
\r   U+000D carriage return
\t   U+0009 horizontal tab
\v   U+000b vertical tab
\\   U+005c backslash
\'   U+0027 single quote  (valid escape only within rune literals)
\"   U+0022 double quote  (valid escape only within string literals)



// ------------------------------------------------------------


註解

//
/* */

// ------------------------------------------------------------



if 條件

與其他程式語言的差異

1、condition 表達式結果必須為布林值
2、支持變量賦值
if var declaration; condition{
// code to be executed if condition is true
}


// ------------------------------------------------------------

switch 條件

與其他程式語言的差異

1、條件表達式不限制為常數或者整數
2、單個 case 中，可以出現多個結果選項，使用逗號分隔
3、與 C 語言等規則相反，Go 語言不需要用 break 來明確退出一個 case
4、可以不設定 switch 之後的條件表達式，在此種情況下，整個 switch 結構與多個 if…else… 的邏輯作用等同

func main() {
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	//break
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.", os)
	}
}

func main() {
	Num := 3
	switch {
	case 0 <= Num && Num <= 3:
		fmt.Println("0-3")
	case 3 <= Num && Num <= 6:
		fmt.Println("3-6")
	case 7 <= Num && Num <= 9:
		fmt.Printf("7-9")
	}
}


// ------------------------------------------------------------

迴圈 for 與變數範圍

func main() {
	for i := 0; i < 5; i++ {
		switch i {
		case 0, 2:
			fmt.Println("Even")
		case 1, 3:
			fmt.Println("Odd")
		default:
			fmt.Println("it is not 0-3")
		}
	}
	//fmt.Println("i =", i) // ./prog.go:18:21: undefined: i
	fmt.Println("----------")

	j := uint8(0)
LOOP:
	for {
		switch {
		case j == 5:
			fmt.Println("j >= 5")
			break LOOP

		case j%2 == 0:
			fmt.Println("Even")
		case j%2 == 1:
			fmt.Println("Odd")
		}
		j++
	}
	fmt.Println("j =", j)
}

// ------------------------------------------------------------

假如您這麼做…

func main() {
	for x := 1; x <= 3; x++ {
		fmt.Println(x)
	}
}

在for鍵詞之後加上括號
for(for x := 1; x <= 3; x++)
→ 有些程式語言需要在for迴圈的控制陳述句外加上小括號，但go不只是不需要它們，它也不容許

從初始陳述句移除:
x=1
→ 除非您賦予值的變數已經在外層的範圍被宣告了（您通常不會這麼做），初始陳述句需要的是宣告，而不是賦值

移除條件表示式中的=
x<3
→ 表示式x<3會在x抵達3之前終止（因為x<=3的情境下依然是true）。於是迴圈只會算到2。

反轉條件表示式中的比較
x>=3
→ 由於條件在迴圈開始之前就為false（x初始化為1，這早就小於3了），迴圈連動都不動。

把後陳述句從x++改成x--
→ 變數x會開始從1倒數（1、0、-1、-2，以此類推）由於條件永遠不會大於3，迴圈永遠不會停

把fmt.Println(x)移到迴圈區塊外
→ 在初始陳述句或者迴圈區塊內宣告的變數，只有在迴圈區塊內的範圍存在。

// ------------------------------------------------------------

使用字串、數值轉換套件：猜數字



// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------

函數是一等公民
https://en.wikipedia.org/wiki/First-class_function

大意是说，在编程语言中，所谓一等公民，是指支持所有操作的实体， 这些操作通常包括作为参数传递，从函数返回，修改并分配给变量等。

比如 int 类型，它支持作为参数传递，可以从函数返回，也可以赋值给变量，因此它是一等公民。

类似的，函数是一等公民，意味着可以把函数赋值给变量或存储在数据结构中，也可以把函数作为其它函数的参数或者返回值。关于函数是一等公民，在维基百科也有定义

// ------------------------------------------------------------

interface 不代表繼承，GO 無繼承

為何 OOP 是 bad idea

1、簡單性是可靠性的前提


// ------------------------------------------------------------

P285
如第4章中的SOLID Design中所述，您了解了Java（和OOP語言）如何強調類型層次結構。 OOP的設計者專注於名詞而不是動詞。 一切都是對象。 對象具有屬性（數據）並且可以執行操作
（方法）。 

OOP的潛在問題之一是，它促進了對象屬性/屬性中數據的存儲和隱藏。 假定我們的應用程序最終將要在執行一個或多個對象的方法時訪問該對象的數據。 

OOP不一致
OOP應用程序可以重新調用其隱藏的信息並對其進行突變。在應用程序的生命週期中，可以多次調用對象的方法。每次對具有相同調用簽名的相同方法的調用每次都會產生不同的結果。其行為的這一特性使OOP不可靠且難以有效測試。
OOP與基本數學不一致。在OOP中，由於對象的可變狀態，我們不能總是每次都用相同的參數調用一個方法，並且總是得到相同的結果。沒有面向對象的數學模型。例如，如果我們調用myMethod（1,2）
並由於可變狀態和對其他對象的內部調用而第一次獲取3並在下次獲取4，因此無法定義OOP程序的正確性。

功能編程和雲計算
功能程序的本質與OOP有很大不同。給定相同的輸入參數集的功能程序將始終產生相同的結果。我們可以輕鬆地並行運行它們。我們可以通過OOP更快，更不可能的方式鏈接/組成它們。
我們的部署模型已經從內部服務器發生了變化，在內部服務器中，管理員將花費大量時間進行配置和優化，以至於給服務器起了個寵物名。我們過去經常看到名稱遵循某種模式，例如希臘諸神。有我們的數據庫服務器Zeus和我們的HR服務器Apollo。

現在我們的服務器已部署在雲中，我們的管理員可以單擊按鈕添加新服務器或設置自動縮放：如果平均CPU超過80％，則添加新服務器。看起來像這樣：


上圖中的Pod代表一台服務器，其中可能有一些相關的容器。容器中的一個容器將運行我們的f（x）函數。如果服務器崩潰，則會通知在容器協調器中運行的自動縮放邏輯，它將自動啟動另一台服務器來替換它。根據我們的雲部署配置文件設置和站點的流量模式，可以快速配置Pod，並停止使用Pod。由於服務器近來來來往往如此便捷，我們稱它們為牛而不是寵物。我們比任何一台特定的寵物服務器更關心服務器群的健康。

具有FP特性的應用程序在我們的雲環境中運行可靠；但是，具有可變狀態的OOP特性的應用程序不會這樣做。

仔細看f（x）
我們來看一個基本的函數定義，其中f是函數名，x是輸入值。 x的另一個名稱是輸入參數。
整個表達式f（x）表示輸出值：
如果f（x）= x + 1，則我們知道每次輸入值2時，輸出值將始終為3。
這種單純的特性使函數式編程如此強大。另一方面，如果我們有一個帶有AddOne方法的對象，當給定值為2時有時返回3，那麼我們如何可靠地縮放object.AddOne方法呢？我們不能，這就是為什麼在雲計算的情況下，以下等式成立的主要原因：FP> OOP。 

仔細研究重構
讓我們根據函數式編程來檢查“重構”書中提出的每個要點。

傳遞函數需要執行其工作的每個參數不是一個好主意
為什麼我們不希望我們的函數簽名指示其需要進行決策的值（參數）？
我們如何減少函數所需的參數？ 

https://segmentfault.com/a/1190000002411278
https://medium.com/%E9%AB%92%E6%A1%B6%E5%AD%90/week30-%E7%B5%90%E6%A7%8B%E5%8C%96-oop%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-fp%E5%87%BD%E6%95%B8%E5%BC%8F%E9%83%BD%E6%9C%89%E4%B8%80%E5%80%8B%E5%A4%A2%E6%83%B3-%E6%89%80%E4%BB%A5%E5%88%A5%E7%88%AD%E4%BA%86%E4%B8%80%E8%B5%B7%E5%8C%96%E7%82%BA%E9%BB%83%E9%87%91%E4%B9%8B%E9%A2%A8%E5%90%A7-296494036747

結論：多看 FP 程式碼吧

// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


// ------------------------------------------------------------


